<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Room: MN History</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Share Tech Mono', monospace; }
        
        /* UI OVERLAYS */
        #instructions {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            text-align: center;
            background: rgba(10, 20, 30, 0.95);
            padding: 40px;
            border: 1px solid #00ffcc;
            border-radius: 10px;
            cursor: pointer;
            z-index: 10;
            user-select: none;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.2), inset 0 0 50px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            max-width: 600px;
        }
        #instructions h1 {
            margin-top: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffcc;
            font-size: 32px;
        }
        #instructions p { font-size: 18px; color: #ccfffc; }
        #instructions b { color: #ffffff; animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            transition: all 0.2s;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 2px; height: 2px;
            background: white;
            transform: translate(-50%, -50%);
        }
        #crosshair.active {
            border-color: #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
            transform: translate(-50%, -50%) scale(1.2);
            background: rgba(0, 255, 204, 0.1);
        }

        /* CLUE MODAL */
        #clueModal {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 650px;
            max-width: 90%;
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.95) 0%, rgba(10, 15, 20, 0.98) 100%);
            color: #e0e0e0;
            border: 1px solid #00ffcc;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 255, 204, 0.3);
            z-index: 20;
            font-family: 'Share Tech Mono', monospace;
            text-align: left;
            overflow: hidden;
        }
        #clueModal::before {
            content: "SECURE CONNECTION ESTABLISHED";
            position: absolute;
            top: 5px; right: 15px;
            font-size: 10px;
            color: #00ffcc;
            opacity: 0.7;
        }

        #clueModal h2 {
            margin-top: 0;
            color: #00ffcc;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(0,255,204,0.5);
        }
        #clueModal p { line-height: 1.6; font-size: 18px; color: #b0bec5; }

        #clueModal .question-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-left: 3px solid #ffb74d;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
            color: #fff;
            font-size: 1.1em;
        }
        
        /* OPTIONS BUTTONS */
        #optionsContainer { display: flex; flex-direction: column; gap: 12px; margin-top: 20px; }
        .option-btn {
            background: rgba(255,255,255,0.05);
            color: #00ffcc;
            border: 1px solid rgba(0,255,204,0.3);
            padding: 15px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Share Tech Mono', monospace;
            font-size: 16px;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        .option-btn:hover {
            background: rgba(0,255,204,0.1);
            border-color: #00ffcc;
            padding-left: 20px;
            box-shadow: 0 0 10px rgba(0,255,204,0.2);
        }
        .option-btn.correct { background: rgba(76, 175, 80, 0.2); border-color: #4caf50; color: #81c784; }
        .option-btn.wrong { background: rgba(229, 57, 53, 0.2); border-color: #e57373; color: #ef9a9a; }

        #modalFeedback { margin-top: 15px; font-weight: bold; min-height: 25px; font-size: 18px; text-align: center;}
        
        #closeModalBtn {
            background: transparent;
            color: #aaa;
            border: 1px solid #555;
            padding: 8px 20px;
            cursor: pointer;
            float: right;
            margin-top: 15px;
            font-family: inherit;
            transition: 0.2s;
            border-radius: 3px;
        }
        #closeModalBtn:hover { background: #333; color: white; border-color: #fff; }

        /* VICTORY MODAL */
        #victoryModal {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: fadeIn 2s ease-in;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        #victoryModal h1 {
            font-size: 80px;
            color: #4caf50;
            text-shadow: 0 0 20px #4caf50;
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-transform: uppercase;
        }
        #victoryModal p {
            font-size: 32px;
            color: #fff;
            margin: 10px 0;
        }
        #victoryTime {
            font-size: 60px;
            color: #ff3333;
            font-family: 'Share Tech Mono', monospace;
            text-shadow: 0 0 20px #ff0000;
            margin-top: 20px;
        }

        /* DOOR KEYPAD UI */
        #keypad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
            max-width: 240px;
            margin-left: auto;
            margin-right: auto;
            background: #111;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }
        .key-btn {
            background: linear-gradient(to bottom, #333, #222);
            border: 1px solid #444;
            color: #eee;
            padding: 15px;
            font-size: 20px;
            cursor: pointer;
            text-align: center;
            border-radius: 5px;
            box-shadow: 0 2px 0 #000;
            transition: 0.1s;
        }
        .key-btn:active { transform: translateY(2px); box-shadow: none; }
        .key-btn:hover { border-color: #00ffcc; color: #00ffcc; }
        #codeDisplay {
            background: #000;
            color: #00ffcc;
            font-family: 'Share Tech Mono', monospace;
            font-size: 32px;
            padding: 15px;
            text-align: center;
            letter-spacing: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0,255,204,0.2);
            text-shadow: 0 0 5px #00ffcc;
        }

    </style>
</head>
<body>

    <div id="instructions">
        <h1>The MN History Escape</h1>
        <p><b>CLICK TO BEGIN</b></p>
        <p>WASD to Move | Mouse to Look</p>
        <p>Find 4 clues to get 4 digits.</p>
        <p>Write them down. You will need them to unlock the door.</p>
    </div>
    
    <div id="crosshair"></div>

    <!-- Clue Modal -->
    <div id="clueModal">
        <h2 id="modalTitle">Evidence Found</h2>
        <div id="modalContent"></div>
        <div id="optionsContainer"></div>
        <div id="modalFeedback"></div>
        <button id="closeModalBtn">Close</button>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal">
        <h1>Mission Accomplished</h1>
        <p>You have escaped the archive.</p>
        <div id="victoryTime"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // --- CUSTOM POINTER LOCK CONTROLS (Patched for stability) ---
        const _euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
        const _vector = new THREE.Vector3();
        const _changeEvent = { type: 'change' };
        const _lockEvent = { type: 'lock' };
        const _unlockEvent = { type: 'unlock' };
        const _PI_2 = Math.PI / 2;

        class PointerLockControls extends THREE.EventDispatcher {
            constructor( camera, domElement ) {
                super();
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.pointerSpeed = 1.0;
                this._onMouseMove = this.onMouseMove.bind( this );
                this._onPointerlockChange = this.onPointerlockChange.bind( this );
                this._onPointerlockError = this.onPointerlockError.bind( this );
                this.connect();
            }
            connect() {
                this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError );
            }
            disconnect() {
                this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError );
            }
            dispose() {
                this.disconnect();
            }
            getObject() {
                return this.camera;
            }
            getDirection( v ) {
                return v.set( 0, 0, - 1 ).applyQuaternion( this.camera.quaternion );
            }
            moveForward( distance ) {
                const camera = this.camera;
                _vector.setFromMatrixColumn( camera.matrix, 0 );
                _vector.crossVectors( camera.up, _vector );
                camera.position.addScaledVector( _vector, distance );
            }
            moveRight( distance ) {
                const camera = this.camera;
                _vector.setFromMatrixColumn( camera.matrix, 0 );
                camera.position.addScaledVector( _vector, distance );
            }
            lock() {
                this.domElement.requestPointerLock();
            }
            unlock() {
                this.domElement.ownerDocument.exitPointerLock();
            }
            onMouseMove( event ) {
                if ( this.isLocked === false ) return;

                // FIX: Clamp movement values to prevent "spinning" or "freaking out" due to browser bugs or large jumps
                const maxDelta = 100;
                let movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                let movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                if (movementX > maxDelta) movementX = maxDelta;
                if (movementX < -maxDelta) movementX = -maxDelta;
                if (movementY > maxDelta) movementY = maxDelta;
                if (movementY < -maxDelta) movementY = -maxDelta;

                const camera = this.camera;
                _euler.setFromQuaternion( camera.quaternion );
                _euler.y -= movementX * 0.002 * this.pointerSpeed;
                _euler.x -= movementY * 0.002 * this.pointerSpeed;
                _euler.x = Math.max( _PI_2 - this.maxPolarAngle, Math.min( _PI_2 - this.minPolarAngle, _euler.x ) );
                camera.quaternion.setFromEuler( _euler );
                this.dispatchEvent( _changeEvent );
            }
            onPointerlockChange() {
                if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) {
                    this.dispatchEvent( _lockEvent );
                    this.isLocked = true;
                } else {
                    this.dispatchEvent( _unlockEvent );
                    this.isLocked = false;
                }
            }
            onPointerlockError() {
                console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );
            }
        }

        // --- GAME DATA POOL ---
        const questionPool = [
            { t: "Flour Power", q: "Which city was the 'Flour Milling Capital of the World'?", o: ["Duluth", "Minneapolis", "St. Paul", "Rochester"], c: 1 },
            { t: "Fur Trade", q: "Which animal pelt was most prized by Voyageurs?", o: ["Bear", "Deer", "Beaver", "Wolf"], c: 2 },
            { t: "Iron Giants", q: "Name the largest Iron Range in MN.", o: ["Mesabi", "Cuyuna", "Vermilion", "Gunflint"], c: 0 },
            { t: "State Seal", q: "The phrase 'L'Etoile du Nord' means:", o: ["Land of Lakes", "Star of the North", "True North", "Cold Waters"], c: 1 },
            { t: "First People", q: "Which group lived in MN forests before the Ojibwe arrived?", o: ["Dakota", "Iroquois", "Apache", "Inuit"], c: 0 },
            { t: "Water Source", q: "Lake Itasca is the source of which river?", o: ["Minnesota", "St. Croix", "Mississippi", "Red"], c: 2 },
            { t: "Early Politics", q: "Who was Minnesota's first state governor?", o: ["Alexander Ramsey", "Henry Sibley", "Knute Nelson", "Hubert Humphrey"], c: 1 },
            { t: "Transport", q: "What was the Red River Cart known for?", o: ["Its speed", "Its squeaky wheels", "Its iron frame", "Floating"], c: 1 },
            { t: "Conflict", q: "The US-Dakota War took place in which year?", o: ["1812", "1862", "1900", "1776"], c: 1 },
            { t: "Immigration", q: "Which European group settled heavily in MN in the late 1800s?", o: ["Italians", "Scandinavians", "Spanish", "Greeks"], c: 1 },
            { t: "Civil War", q: "MN was the first state to offer troops to the Union. Which regiment is famous?", o: ["1st Minnesota", "Iron Brigade", "Rough Riders", "Green Mountain Boys"], c: 0 },
            { t: "Folklore", q: "Who is the legendary giant lumberjack of MN folklore?", o: ["Pecos Bill", "John Henry", "Paul Bunyan", "Johnny Appleseed"], c: 2 },
            { t: "Geography", q: "What is the largest lake entirely within Minnesota?", o: ["Mille Lacs", "Red Lake", "Leech Lake", "Lake Minnetonka"], c: 1 },
            { t: "Capital City", q: "Which city is the capital of Minnesota?", o: ["Minneapolis", "St. Paul", "Duluth", "Bloomington"], c: 1 },
            { t: "Territory", q: "Before statehood, MN was a territory. In what year did it become a territory?", o: ["1849", "1858", "1800", "1890"], c: 0 }
        ];

        let activeClues = [
            { digit: 1, qIndex: 0, solved: false },
            { digit: 8, qIndex: 1, solved: false },
            { digit: 5, qIndex: 2, solved: false },
            { digit: 8, qIndex: 3, solved: false }
        ];
        let hasSkeletonKey = false;
        let safeAttempts = 3;

        // Expanded locations list
        const locations = [
            "computer", "filing_cabinet_1", "filing_cabinet_2", "filing_cabinet_3", "papers", "safe", 
            "briefcase", "mug", "hat", "lamp", 
            "globe", "radio", "typewriter", "plant", "trophy", "clock", "trash", "lunchbox",
            "picture", "desk_lamp", "cardboard_box", "fire_extinguisher",
            "book_cluster_1", "book_cluster_2", "book_cluster_3", "book_cluster_4",
            "keyboard", "mouse", "open_book"
        ];
        
        let locationMap = {};

        function initGame() {
            locations.forEach(loc => locationMap[loc] = null);
            questionPool.sort(() => 0.5 - Math.random());
            for(let i=0; i<4; i++) {
                activeClues[i].qIndex = i; 
                activeClues[i].solved = false;
            }
            const shuffledLocs = [...locations].sort(() => 0.5 - Math.random());
            for(let i=0; i<4; i++) {
                locationMap[shuffledLocs[i]] = i;
            }
            safeAttempts = 3;
        }
        initGame();

        function resetGameLogic() {
            modalTitle.textContent = "SYSTEM RESET";
            modalContent.innerHTML = "<h2 style='color:red'>SECURITY LOCKOUT</h2><p>Too many failed attempts.</p><p>Clues have been relocated. Codes reset.</p>";
            optionsContainer.innerHTML = "";
            
            // Reset internals
            initGame();
            
            setTimeout(() => {
                modal.style.display = 'none';
                controls.lock();
            }, 3000);
        }

        // ... (Scene Setup remains same) ... 


        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xebe5ce); 
        scene.fog = new THREE.Fog(0xebe5ce, 5, 30);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3.5, 1.6, 3.5); 
        camera.lookAt(0, 1.4, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; 
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        controls.pointerSpeed = 0.3;
        controls.minPolarAngle = 0.5;
        controls.maxPolarAngle = 2.5; 

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); 
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffdfba, 1.2); 
        dirLight.position.set(-10, 8, 2); 
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const lights = [
            {x: 2.8, y: 1.8, z: -3.2, col: 0xffaa00, int: 1.2},
            {x: -1, y: 2.0, z: 1.5, col: 0xffddaa, int: 0.8},
            {x: 3.5, y: 2.5, z: 3.5, col: 0xffeebb, int: 0.8}
        ];
        lights.forEach(l => {
            const pl = new THREE.PointLight(l.col, l.int, 8);
            pl.position.set(l.x, l.y, l.z);
            pl.castShadow = true;
            scene.add(pl);
        });

        // --- MATERIALS ---
        const colors = { wall: 0xebe5ce, trim: 0x4e342e, floor: 0x5d4037, shelf: 0x263238, cork: 0x8d6e63 };
        // Computer Screen Texture
        const compCanvas = document.createElement('canvas'); compCanvas.width = 512; compCanvas.height = 512;
        const cCtx = compCanvas.getContext('2d');
        cCtx.fillStyle = '#000000'; cCtx.fillRect(0,0,512,512);
        cCtx.fillStyle = '#002200'; cCtx.font = '20px monospace';
        for(let i=0; i<20; i++) cCtx.fillText(Math.random().toString(2).substring(2), 10, 30 + i*24);
        cCtx.fillStyle = '#00ffcc'; cCtx.font = 'bold 40px "Share Tech Mono", monospace'; cCtx.textAlign = 'center';
        cCtx.shadowColor='#00ffcc'; cCtx.shadowBlur=20;
        cCtx.fillText("SYSTEM LOCKED", 256, 200);
        cCtx.font = '20px "Share Tech Mono", monospace';
        cCtx.fillText("MN HISTORY ARCHIVE", 256, 250);
        cCtx.strokeStyle = '#00ffcc'; cCtx.lineWidth=5; cCtx.strokeRect(50, 140, 412, 150);

        const mat = {
            wall: new THREE.MeshStandardMaterial({ color: colors.wall, roughness: 0.9 }),
            floor: new THREE.MeshStandardMaterial({ color: colors.floor, roughness: 0.8 }),
            shelf: new THREE.MeshLambertMaterial({ color: colors.shelf }),
            woodDark: new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.7 }),
            woodOld: new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 }),
            chrome: new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 }),
            leather: new THREE.MeshStandardMaterial({ color: 0x4e342e, roughness: 0.4 }),
            glass: new THREE.MeshBasicMaterial({ color: 0x88ccff, opacity: 0.1, transparent: true }),
            trim: new THREE.MeshLambertMaterial({ color: colors.trim }),
            paper: new THREE.MeshLambertMaterial({ color: 0xfffdf0 }),
            rug: new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1.0 }),
            door: new THREE.MeshStandardMaterial({ color: 0x3e2723 }),
            cork: new THREE.MeshStandardMaterial({ color: colors.cork, roughness: 1.0 }),
            safe: new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7, roughness: 0.3 }),
            screenOn: new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(compCanvas) }),
            cabinet: new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.4, roughness: 0.5 }),
            bookColors: [0x3e2723, 0x263238, 0x1b5e20, 0x880e4f, 0xbf360c, 0x004d40],
            gold: new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }),
            plantGreen: new THREE.MeshLambertMaterial({ color: 0x2e7d32 }),
            trashCan: new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 })
        };

        // --- UTILS ---
        const interactables = []; 
        function createBox(w, h, d, matOrColor, x, y, z, parent = scene, rX=0, rY=0, rZ=0, name=null) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const material = (typeof matOrColor === 'number') ? new THREE.MeshLambertMaterial({ color: matOrColor }) : matOrColor;
            const mesh = new THREE.Mesh(geo, material);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rX, rY, rZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            if(name) {
                mesh.name = name;
                interactables.push(mesh);
            }
            parent.add(mesh);
            return mesh;
        }

        // --- ROOM ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), mat.floor);
        floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
        createBox(20, 4, 0.2, mat.wall, 0, 2, -5); 
        createBox(20, 4, 0.2, mat.wall, 0, 2, 5);  
        createBox(0.2, 1.0, 20, mat.wall, -5, 0.5, 0); createBox(0.2, 1.0, 20, mat.wall, -5, 3.5, 0);
        createBox(0.2, 2.0, 8, mat.wall, -5, 2.0, -6); createBox(0.2, 2.0, 8, mat.wall, -5, 2.0, 6);
        createBox(0.2, 4, 9.25, mat.wall, 5, 2, -5.375); 
        createBox(0.2, 4, 9.25, mat.wall, 5, 2, 5.375); 
        createBox(0.2, 1.8, 1.5, mat.wall, 5, 3.1, 0); 
        createBox(20, 0.2, 20, mat.trim, 0, 4.1, 0); 

        // --- PROPS ---
        // Filing Cabinets (Back Wall)
        const cabinetGroup = new THREE.Group(); cabinetGroup.position.set(0, 0, 4.6); cabinetGroup.rotation.y = Math.PI; scene.add(cabinetGroup);
        for(let i=-1; i<=1; i++) {
            const cabName = `filing_cabinet_${i+2}`;
            const cab = createBox(0.8, 1.5, 0.6, mat.cabinet, i * 1.0, 0.75, 0, cabinetGroup, 0, 0, 0, cabName);
            // Drawers detail
            createBox(0.7, 0.02, 0.01, 0x333333, 0, 0.5, 0.31, cab); // Top drawer line
            createBox(0.7, 0.02, 0.01, 0x333333, 0, 0.0, 0.31, cab); // Mid drawer line
            createBox(0.7, 0.02, 0.01, 0x333333, 0, -0.5, 0.31, cab); // Bottom drawer line
            // Handles and Labels
            [0.5, 0.0, -0.5].forEach(y => {
                createBox(0.1, 0.05, 0.02, 0xdddddd, 0, y + 0.1, 0.31, cab); // Label holder
                createBox(0.15, 0.03, 0.04, 0x222222, 0, y - 0.1, 0.32, cab); // Handle
            });
        }
        
        // Safe
        const safeGroup = new THREE.Group(); safeGroup.position.set(4.0, 0, 4.2); safeGroup.rotation.y = -Math.PI / 4;
        const safeBox = createBox(0.8, 1.0, 0.8, mat.safe, 0, 0.5, 0, safeGroup, 0,0,0, "safe");
        // Safe Details
        const sDial = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16), new THREE.MeshStandardMaterial({color: 0xcccccc}));
        sDial.rotation.x = Math.PI / 2; sDial.position.set(0, 0.2, 0.41); safeBox.add(sDial);
        createBox(0.05, 0.2, 0.05, 0xcccccc, 0.2, 0, 0.45, safeBox); // Handle
        createBox(0.7, 0.9, 0.02, 0x222222, 0, 0, 0.405, safeBox); // Door seam
        scene.add(safeGroup);
        
        // Computer Desk
        const deskGroup = new THREE.Group(); deskGroup.position.set(2.5, 0, -3.0); scene.add(deskGroup);
        createBox(1.8, 0.05, 3.5, mat.woodDark, 0, 0.75, 0, deskGroup);
        createBox(1.6, 0.75, 0.2, mat.shelf, 0, 0.375, 1.55, deskGroup); createBox(1.6, 0.75, 0.2, mat.shelf, 0, 0.375, -1.55, deskGroup);
        
        // Computer Monitor (Rotated 90 deg)
        const pcGroup = new THREE.Group();
        pcGroup.position.set(0, 0.8, 0); 
        // ROTATED 90 DEG CLOCKWISE from Math.PI/2 -> 0
        pcGroup.rotation.y = 0; 
        deskGroup.add(pcGroup);
        createBox(0.1, 0.3, 0.1, 0x222222, 0, 0.15, 0, pcGroup); 
        createBox(0.05, 0.6, 1.0, 0x222222, 0, 0.5, 0, pcGroup);
        createBox(0.01, 0.55, 0.95, mat.screenOn, -0.03, 0.5, 0, pcGroup, 0, 0, 0, "computer");
        
        // Keyboard
        const kbGroup = new THREE.Group(); kbGroup.position.set(-0.4, 0.76, 0); deskGroup.add(kbGroup);
        createBox(0.3, 0.02, 0.8, 0x222222, 0, 0, 0, kbGroup, 0,0,0, "keyboard");
        // Keys hint
        for(let kx=0; kx<3; kx++) for(let kz=0; kz<8; kz++) {
            createBox(0.04, 0.01, 0.04, 0x444444, -0.08 + kx*0.08, 0.015, -0.3 + kz*0.08, kbGroup);
        }

        // Mouse
        const mouseMesh = createBox(0.12, 0.04, 0.08, 0x333333, -0.4, 0.76, 0.6, deskGroup, 0, 0, 0, "mouse");
        
        // Open Book
        const openBook = new THREE.Group(); openBook.position.set(0.4, 0.76, 0.6); openBook.rotation.y = 0.2; deskGroup.add(openBook);
        const lPage = createBox(0.25, 0.02, 0.18, 0xeeeeee, 0, 0.01, -0.09, openBook); lPage.rotation.x = 0.1;
        const rPage = createBox(0.25, 0.02, 0.18, 0xeeeeee, 0, 0.01, 0.09, openBook); rPage.rotation.x = -0.1;
        const hitBook = createBox(0.3, 0.1, 0.4, new THREE.MeshBasicMaterial({visible:false}), 0, 0, 0, openBook, 0,0,0, "open_book");
        interactables.push(hitBook);

        const deskChair = new THREE.Group(); deskChair.position.set(1.2, 0, -3.0); deskChair.rotation.y = -Math.PI / 2; scene.add(deskChair);
        const cBase = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.1, 8), mat.chrome); cBase.position.y = 0.1; deskChair.add(cBase);
        createBox(0.05, 0.4, 0.05, mat.chrome, 0, 0.3, 0, deskChair); createBox(0.65, 0.1, 0.65, mat.leather, 0, 0.55, 0, deskChair);
        const cBack = createBox(0.6, 0.9, 0.1, mat.leather, 0, 1.0, 0.25, deskChair); cBack.rotation.x = -0.15;
        
        // Table
        const tableGroup = new THREE.Group(); tableGroup.position.set(-1, 0, 1.5); tableGroup.rotation.y = 0.2; scene.add(tableGroup);
        createBox(2.5, 0.1, 1.2, mat.woodOld, 0, 0.75, 0, tableGroup);
        createBox(0.1, 0.7, 0.1, mat.woodOld, -1.1, 0.35, -0.5, tableGroup); createBox(0.1, 0.7, 0.1, mat.woodOld, 1.1, 0.35, -0.5, tableGroup);
        createBox(0.1, 0.7, 0.1, mat.woodOld, -1.1, 0.35, 0.5, tableGroup); createBox(0.1, 0.7, 0.1, mat.woodOld, 1.1, 0.35, 0.5, tableGroup);
        
        function createPaperStack(x, z, parent) {
            const group = new THREE.Group(); group.position.set(x, 0.76, z);
            for(let i=0; i<10; i++) {
                const paper = new THREE.Mesh(new THREE.PlaneGeometry(0.25, 0.35), mat.paper);
                paper.rotation.x = -Math.PI/2; paper.rotation.z = Math.random() * 0.5; paper.position.y = i * 0.005; group.add(paper);
            }
            const hitBox = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.4), new THREE.MeshBasicMaterial({visible: false}));
            hitBox.name = "papers"; interactables.push(hitBox); group.add(hitBox); parent.add(group);
        }
        createPaperStack(0, 0, tableGroup); createPaperStack(-0.8, 0.2, tableGroup);
        
        // Shelves
        const shelfGroup = new THREE.Group(); shelfGroup.position.set(0, 0, -4.8); scene.add(shelfGroup);
        const shelfHeight = 3.5; const shelfDepth = 0.4; const shelfLevels = [0.2, 1.0, 1.8, 2.6, 3.4]; 
        [-4.5, -2.5, -0.5, 1.5, 3.5].forEach(x => createBox(0.1, shelfHeight, shelfDepth, colors.shelf, x, shelfHeight/2, 0, shelfGroup));
        shelfLevels.forEach(y => createBox(8.2, 0.05, shelfDepth, colors.shelf, -0.5, y, 0, shelfGroup));
        function createBook(x, y, z, parent) {
            const h = 0.2 + Math.random() * 0.15; const t = 0.04 + Math.random() * 0.04; const d = 0.22 + Math.random() * 0.05;
            const col = mat.bookColors[Math.floor(Math.random() * mat.bookColors.length)];
            const book = createBox(t, h, d, col, 0, 0, 0, parent); book.position.set(x, y + h/2, z);
            if(Math.random() > 0.8) book.rotation.z = (Math.random() - 0.5) * 0.2; return t;
        }
        const shelfZones = [{minX: -4.4, maxX: -2.6}, {minX: -2.4, maxX: -0.6}, {minX: -0.4, maxX: 1.4}, {minX: 1.6, maxX: 3.4}];
        let bClusterIdx = 0;
        shelfLevels.forEach((level, lvlIndex) => {
            if(lvlIndex === 0) return; 
            shelfZones.forEach((zone) => {
                let cx = zone.minX + 0.1;
                
                // Always attempt to create a cluster if we haven't made 4 yet
                if (bClusterIdx < 4) {
                     bClusterIdx++;
                     const bw = (zone.maxX - zone.minX) * 0.9;
                     // Create invisible interaction box
                     const bhit = createBox(bw, 0.4, 0.3, new THREE.MeshBasicMaterial({visible:false}), (zone.minX+zone.maxX)/2, level+0.2, 0, shelfGroup, 0,0,0, `book_cluster_${bClusterIdx}`);
                     interactables.push(bhit); // Ensure it's added to interactables manually if createBox didn't (createBox does if name provided)
                     
                     // Fill with books
                     while(cx < zone.maxX - 0.15) { cx += createBook(cx, level, 0, shelfGroup) + 0.002; }
                } 
                else { 
                    // Random filler for remaining shelves
                    if (Math.random() > 0.3) {
                        while(cx < zone.maxX - 0.15) { cx += createBook(cx, level, 0, shelfGroup) + 0.002; } 
                    } else {
                        createBox(0.4, 0.25, 0.3, 0x8d6e63, cx+0.25, level+0.125, 0, shelfGroup); 
                        cx += 0.6; 
                        while(cx < zone.maxX - 0.1) cx += createBook(cx, level, 0, shelfGroup) + 0.002; 
                    }
                }
            });
        });

        // Lounge
        const loungeGroup = new THREE.Group(); loungeGroup.position.set(2.5, 0, 2.5); loungeGroup.rotation.y = -Math.PI / 4; scene.add(loungeGroup);
        const armChair = new THREE.Group();
        createBox(0.8, 0.4, 0.8, mat.leather, 0, 0.2, 0, armChair); createBox(0.8, 0.8, 0.2, mat.leather, 0, 0.6, 0.3, armChair);
        createBox(0.2, 0.6, 0.8, mat.leather, -0.3, 0.3, 0, armChair); createBox(0.2, 0.6, 0.8, mat.leather, 0.3, 0.3, 0, armChair);
        loungeGroup.add(armChair);
        
        const coffeeTable = new THREE.Group(); coffeeTable.position.set(0, 0, -1.2);
        createBox(1.0, 0.05, 0.6, mat.woodDark, 0, 0.4, 0, coffeeTable);
        createBox(0.05, 0.4, 0.05, mat.chrome, -0.45, 0.2, -0.25, coffeeTable); createBox(0.05, 0.4, 0.05, mat.chrome, 0.45, 0.2, -0.25, coffeeTable);
        createBox(0.05, 0.4, 0.05, mat.chrome, -0.45, 0.2, 0.25, coffeeTable); createBox(0.05, 0.4, 0.05, mat.chrome, 0.45, 0.2, 0.25, coffeeTable);
        loungeGroup.add(coffeeTable);
        
        // Mug (Detailed)
        const mugGroup = new THREE.Group(); mugGroup.position.set(0.2, 0.47, -0.1); 
        const mugBody = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.1, 16), new THREE.MeshLambertMaterial({color: 0xffffff}));
        mugBody.name = "mug"; interactables.push(mugBody);
        mugGroup.add(mugBody);
        const mugHandle = new THREE.Mesh(new THREE.TorusGeometry(0.03, 0.008, 6, 12), new THREE.MeshLambertMaterial({color: 0xffffff}));
        mugHandle.position.set(0.05, 0, 0); mugHandle.rotation.z = 0; mugGroup.add(mugHandle);
        coffeeTable.add(mugGroup);
        
        // Floor Lamp (Detailed)
        const floorLamp = new THREE.Group(); floorLamp.position.set(1.0, 0, 0.5);
        createBox(0.3, 0.05, 0.3, mat.chrome, 0, 0.025, 0, floorLamp); // Base
        createBox(0.04, 1.8, 0.04, mat.chrome, 0, 0.9, 0, floorLamp); // Pole
        const lampshade = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 0.4, 16, 1, true), new THREE.MeshLambertMaterial({color: 0xffeebb, side: THREE.DoubleSide}));
        lampshade.position.set(0, 1.9, 0); 
        const lampHit = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.5), new THREE.MeshBasicMaterial({visible: false}));
        lampHit.position.set(0, 1.9, 0); lampHit.name = "lamp"; interactables.push(lampHit); floorLamp.add(lampHit);
        floorLamp.add(lampshade);
        const lampBulb = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({color: 0xffffcc}));
        lampBulb.position.set(0, 1.8, 0); floorLamp.add(lampBulb);
        loungeGroup.add(floorLamp);
        
        const bagGroup = new THREE.Group(); bagGroup.position.set(2.5, 0, 4.0); bagGroup.rotation.y = 0.5;
        const bagBody = createBox(0.6, 0.4, 0.15, mat.leather, 0, 0.2, 0, bagGroup);
        bagBody.name = "briefcase"; interactables.push(bagBody);
        createBox(0.02, 0.1, 0.1, mat.chrome, 0, 0.4, 0, bagGroup); scene.add(bagGroup);
        
        const rackGroup = new THREE.Group(); rackGroup.position.set(4.5, 0, -2.5);
        createBox(0.05, 1.8, 0.05, mat.woodDark, 0, 0.9, 0, rackGroup);
        const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.1), new THREE.MeshStandardMaterial({color: 0x333333}));
        hat.position.set(0.1, 1.82, 0); hat.rotation.z = 0.2; hat.name = "hat"; interactables.push(hat);
        rackGroup.add(hat); scene.add(rackGroup);

        // --- NEW INTERACTIVE OBJECTS ---
        // 1. Globe (On cabinet)
        const globeGroup = new THREE.Group();
        globeGroup.position.set(0, 1.5, 0);
        cabinetGroup.add(globeGroup);
        const gBase = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.05), mat.woodDark);
        globeGroup.add(gBase);
        
        // Generate Globe Texture
        const globeCanvas = document.createElement('canvas'); 
        globeCanvas.width = 512; globeCanvas.height = 256;
        const gCtx = globeCanvas.getContext('2d');
        gCtx.fillStyle = '#1565c0'; gCtx.fillRect(0, 0, 512, 256); // Ocean
        gCtx.fillStyle = '#43a047'; // Land
        // Simplified continents approximation
        // N. America
        gCtx.beginPath(); gCtx.ellipse(100, 60, 40, 30, 0.5, 0, Math.PI*2); gCtx.fill();
        // S. America
        gCtx.beginPath(); gCtx.ellipse(140, 170, 30, 50, -0.2, 0, Math.PI*2); gCtx.fill();
        // Europe/Africa
        gCtx.beginPath(); gCtx.ellipse(260, 120, 50, 60, 0, 0, Math.PI*2); gCtx.fill();
        // Asia
        gCtx.beginPath(); gCtx.ellipse(360, 70, 60, 40, 0, 0, Math.PI*2); gCtx.fill();
        // Australia
        gCtx.beginPath(); gCtx.ellipse(430, 180, 25, 20, 0, 0, Math.PI*2); gCtx.fill();
        // Antarctica
        gCtx.fillStyle = '#eeeeee';
        gCtx.fillRect(0, 230, 512, 26);

        const globeTex = new THREE.CanvasTexture(globeCanvas);
        const gSphere = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshPhongMaterial({map: globeTex}));
        gSphere.rotation.y = -1.5; // Adjust initial rotation
        gSphere.position.y = 0.25; 
        gSphere.name = "globe"; interactables.push(gSphere); 
        globeGroup.add(gSphere);

        // 2. Radio (Window Seat)
        const radio = createBox(0.4, 0.25, 0.2, 0x5d4037, -3.5, 0.35, -4.2, scene, 0, 0.2, 0, "radio");
        createBox(0.1, 0.1, 0.02, 0xdddddd, 0.1, 0, 0.1, radio); // Speaker mesh area

        // 3. Typewriter (Table)
        const typewriter = createBox(0.4, 0.15, 0.35, 0x222222, 0.5, 0.85, -0.2, tableGroup, 0, -0.2, 0, "typewriter");
        createBox(0.3, 0.1, 0.1, 0xdddddd, 0, 0.1, -0.1, typewriter); // Paper roller

        // 4. Plant (Corner)
        const plantGroup = new THREE.Group();
        plantGroup.position.set(-4.5, 0, -4.5);
        const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.4), new THREE.MeshLambertMaterial({color: 0x8d6e63}));
        pot.position.y = 0.2;
        plantGroup.add(pot);
        const foliage = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), mat.plantGreen);
        foliage.position.y = 0.6;
        foliage.name = "plant"; interactables.push(foliage);
        plantGroup.add(foliage);
        scene.add(plantGroup);

        // 5. Trophy (Shelf)
        const trophy = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.05, 0.3), mat.gold);
        trophy.position.set(1.0, 2.8, 0); // On high shelf
        trophy.name = "trophy"; interactables.push(trophy);
        shelfGroup.add(trophy);

        // 6. Wall Clock (Above Window)
        const clockGroup = new THREE.Group();
        clockGroup.position.set(-4.9, 3.5, 0);
        clockGroup.rotation.y = Math.PI/2;
        
        // Clock Face Texture
        const clockCanvas = document.createElement('canvas'); clockCanvas.width=128; clockCanvas.height=128;
        const clockCtx = clockCanvas.getContext('2d');
        clockCtx.fillStyle = '#ffffff'; clockCtx.fillRect(0,0,128,128);
        clockCtx.fillStyle = '#000000'; clockCtx.beginPath(); clockCtx.arc(64,64,60,0,Math.PI*2); clockCtx.stroke();
        for(let i=0; i<12; i++) {
             const a = (i/12) * Math.PI*2; 
             const r = (i%3===0) ? 10 : 5;
             clockCtx.fillRect(64 + Math.sin(a)*50 - (i%3===0?2:1), 64 - Math.cos(a)*50 - (i%3===0?2:1), (i%3===0?4:2), r);
        }
        // Hands
        const nowTime = new Date();
        const hA = (nowTime.getHours() % 12 + nowTime.getMinutes()/60) / 12 * Math.PI*2;
        const mA = nowTime.getMinutes() / 60 * Math.PI*2;
        clockCtx.strokeStyle='#000'; clockCtx.lineWidth=3; clockCtx.beginPath(); clockCtx.moveTo(64,64); clockCtx.lineTo(64+Math.sin(hA)*30, 64-Math.cos(hA)*30); clockCtx.stroke();
        clockCtx.lineWidth=2; clockCtx.beginPath(); clockCtx.moveTo(64,64); clockCtx.lineTo(64+Math.sin(mA)*45, 64-Math.cos(mA)*45); clockCtx.stroke();

        const clockTex = new THREE.CanvasTexture(clockCanvas);
        const clockBody = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.05), new THREE.MeshLambertMaterial({color: 0xffffff}));
        clockBody.rotation.x = Math.PI/2;
        clockGroup.add(clockBody);
        
        const clockFace = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), new THREE.MeshBasicMaterial({map: clockTex, transparent:true}));
        clockFace.position.z = 0.03; 
        clockFace.name = "clock"; interactables.push(clockFace);
        clockGroup.add(clockFace);
        scene.add(clockGroup);

        // 7. Trash Can (Under desk)
        const trashCan = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.5), mat.trashCan);
        trashCan.position.set(2.5, 0.25, -2.0);
        trashCan.name = "trash"; interactables.push(trashCan);
        scene.add(trashCan);

        // 8. Lunchbox (Coffee Table) (Detailed)
        const lunchGroup = new THREE.Group(); lunchGroup.position.set(-0.2, 0.55, 0.1); coffeeTable.add(lunchGroup);
        const lunchBody = createBox(0.3, 0.2, 0.2, 0xff0000, 0, 0, 0, lunchGroup);
        lunchBody.name = "lunchbox"; interactables.push(lunchBody);
        const lHandle = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.01, 4, 12), new THREE.MeshBasicMaterial({color: 0x333333}));
        lHandle.position.set(0, 0.1, 0); lHandle.rotation.x = Math.PI/2; lunchGroup.add(lHandle);
        createBox(0.04, 0.05, 0.01, 0xcccccc, -0.08, 0.05, 0.1, lunchGroup); // Latch
        createBox(0.04, 0.05, 0.01, 0xcccccc, 0.08, 0.05, 0.1, lunchGroup); // Latch

        // 9. Framed Picture (Right Wall)
        const pictureGroup = new THREE.Group();
        pictureGroup.position.set(4.9, 2.5, 2.5);
        pictureGroup.rotation.y = -Math.PI / 2;
        createBox(1.5, 1.0, 0.05, 0x333333, 0, 0, 0, pictureGroup); // Frame
        const canvasPic = document.createElement('canvas'); canvasPic.width=128; canvasPic.height=128;
        const pCtx = canvasPic.getContext('2d');
        pCtx.fillStyle = '#87CEEB'; pCtx.fillRect(0,0,128,128);
        pCtx.fillStyle = '#228B22'; pCtx.beginPath(); pCtx.moveTo(64,20); pCtx.lineTo(100,100); pCtx.lineTo(28,100); pCtx.fill();
        const picTex = new THREE.CanvasTexture(canvasPic);
        const picMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.3, 0.8), new THREE.MeshBasicMaterial({map: picTex}));
        picMesh.position.z = 0.03;
        picMesh.name = "picture"; interactables.push(picMesh);
        pictureGroup.add(picMesh);
        scene.add(pictureGroup);

        // 10. Desk Lamp (On Desk) (Detailed)
        const deskLamp = new THREE.Group();
        deskLamp.position.set(3.0, 0.8, -3.2);
        const dlBase = createBox(0.15, 0.02, 0.15, 0x222222, 0, 0, 0, deskLamp);
        const dlPole1 = createBox(0.02, 0.2, 0.02, 0x222222, 0, 0.1, 0, deskLamp);
        dlPole1.rotation.x = 0.3;
        const dlPole2 = createBox(0.02, 0.2, 0.02, 0x222222, 0, 0.25, 0.08, deskLamp);
        dlPole2.rotation.x = 1.0;
        const dlHead = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.15, 16, 1, true), new THREE.MeshLambertMaterial({color: 0x333333, side: THREE.DoubleSide}));
        dlHead.position.set(0, 0.25, 0.25);
        dlHead.rotation.x = 2.0;
        dlHead.name = "desk_lamp"; interactables.push(dlHead);
        const dlBulb = new THREE.Mesh(new THREE.SphereGeometry(0.04), new THREE.MeshBasicMaterial({color: 0xffffcc}));
        dlBulb.position.set(0, -0.05, 0); dlHead.add(dlBulb);
        deskLamp.add(dlHead);
        scene.add(deskLamp);

        // 11. Cardboard Box (Corner)
        const boxGroup = new THREE.Group();
        boxGroup.position.set(-4.2, 0.3, 4.2);
        boxGroup.rotation.y = 0.4;
        const boxMesh = createBox(0.6, 0.6, 0.6, 0xcdb38b, 0, 0, 0, boxGroup, 0, 0, 0, "cardboard_box");
        createBox(0.58, 0.01, 0.28, 0xbe9e6d, 0, 0.305, -0.15, boxGroup); // Flap
        createBox(0.58, 0.01, 0.28, 0xbe9e6d, 0, 0.305, 0.15, boxGroup); // Flap
        scene.add(boxGroup);

        // 12. Fire Extinguisher (Near Door)
        const feGroup = new THREE.Group();
        feGroup.position.set(4.5, 0.0, -1.5); // On floor near wall
        const feTank = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.6), new THREE.MeshPhongMaterial({color: 0xcc0000}));
        feTank.position.y = 0.3;
        feTank.name = "fire_extinguisher"; interactables.push(feTank);
        feGroup.add(feTank);
        createBox(0.05, 0.1, 0.05, 0x111111, 0, 0.65, 0, feGroup); // Nozzle top
        scene.add(feGroup);


        // --- DOOR & TIMER ---
        const doorGroup = new THREE.Group(); doorGroup.position.set(5, 0, 0); doorGroup.rotation.y = -Math.PI / 2; scene.add(doorGroup);
        createBox(1.7, 2.3, 0.15, mat.trim, 0, 1.15, 0, doorGroup);

        // Door Pivot Group for hinging
        const doorPivot = new THREE.Group();
        doorPivot.position.set(-0.75, 1.1, 0.02); // Hinge location (left side of door)
        doorGroup.add(doorPivot);

        // Door Mesh (relative to pivot)
        // Door is 1.5 wide. Center is at +0.75 relative to pivot.
        const theDoor = createBox(1.5, 2.2, 0.05, mat.door, 0.75, 0, 0, doorPivot, 0,0,0, "door");

        // Knob (relative to pivot)
        // Old knob pos in doorGroup: 0.6, 1.1, 0.08
        // Pivot pos in doorGroup: -0.75, 1.1, 0.02
        // Relative x: 0.6 - (-0.75) = 1.35
        // Relative y: 1.1 - 1.1 = 0
        // Relative z: 0.08 - 0.02 = 0.06
        const knob = new THREE.Mesh(new THREE.SphereGeometry(0.04), mat.chrome);
        knob.position.set(1.35, 0, 0.06);
        doorPivot.add(knob);

        const timerGroup = new THREE.Group(); timerGroup.position.set(0, 2.6, 0.1); doorGroup.add(timerGroup);
        createBox(0.8, 0.3, 0.1, new THREE.MeshStandardMaterial({color:0x111111}), 0, 0, 0, timerGroup);
        const timerCanvas = document.createElement('canvas'); timerCanvas.width = 512; timerCanvas.height = 256;
        const tCtx = timerCanvas.getContext('2d');
        const timerTexture = new THREE.CanvasTexture(timerCanvas);
        const displayMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.35), new THREE.MeshBasicMaterial({ map: timerTexture }));
        displayMesh.position.z = 0.06; timerGroup.add(displayMesh);
        let timeLeft = 600;
        let gameWon = false;
        let finalTimeStr = "00:00";

        function updateTimer(dt) {
            if(!gameWon) timeLeft = Math.max(0, timeLeft - dt);
            const m = Math.floor(timeLeft / 60);
            const s = Math.floor(timeLeft % 60);
            finalTimeStr = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            const timeStr = finalTimeStr;

            // Background
            tCtx.fillStyle = '#050505';
            tCtx.fillRect(0, 0, 512, 256);

            // Scanlines
            tCtx.fillStyle = 'rgba(0, 255, 0, 0.05)';
            for(let i=0; i<256; i+=4) tCtx.fillRect(0, i, 512, 1);

            // Glow & Text
            tCtx.shadowColor = "#ff0000";
            tCtx.shadowBlur = 30;
            tCtx.fillStyle = '#ff3333';
            tCtx.font = 'bold 140px "Share Tech Mono", monospace';
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            tCtx.fillText(timeStr, 256, 128);

            // Border
            tCtx.strokeStyle = "#550000";
            tCtx.lineWidth = 10;
            tCtx.strokeRect(5, 5, 502, 246);

            timerTexture.needsUpdate = true;
        }

        // --- LOGIC ---
        const crosshair = document.getElementById('crosshair');
        const modal = document.getElementById('clueModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');
        const optionsContainer = document.getElementById('optionsContainer');
        const modalFeedback = document.getElementById('modalFeedback');
        const closeBtn = document.getElementById('closeModalBtn');
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);

        let currentCode = "";
        let isInteracting = false;

        closeBtn.addEventListener('click', () => {
            isInteracting = false;
            modal.style.display = 'none';
            controls.lock(); 
        });

        function checkIntersection() {
            raycaster.far = 5.0; // Increased interaction distance for high/far objects
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(interactables, false);
            if (intersects.length > 0) {
                crosshair.classList.add('active');
                return intersects[0].object;
            } else {
                crosshair.classList.remove('active');
                return null;
            }
        }

        function moveClue(slotIndex, fromObjName) {
            const emptyLocs = locations.filter(loc => locationMap[loc] === null && loc !== fromObjName);
            if(emptyLocs.length > 0) {
                const newLoc = emptyLocs[Math.floor(Math.random() * emptyLocs.length)];
                locationMap[newLoc] = slotIndex;
                locationMap[fromObjName] = null;
                
                const usedQIndices = activeClues.map(c => c.qIndex);
                const availableQIndices = [];
                for(let i=0; i<questionPool.length; i++) {
                    if(!usedQIndices.includes(i)) availableQIndices.push(i);
                }
                if(availableQIndices.length > 0) {
                    const newQIndex = availableQIndices[Math.floor(Math.random() * availableQIndices.length)];
                    activeClues[slotIndex].qIndex = newQIndex;
                }
                return newLoc;
            }
            return null;
        }

        function renderSafeKeypad() {
            modalTitle.textContent = "SAFE LOCK";
            
            const solvedCount = activeClues.filter(c => c.solved).length;
            const allSolved = solvedCount === 4;
            
            // Gather collected digits
            let collectedDigits = activeClues.filter(c => c.solved).map(c => c.digit);
            collectedDigits.sort(); // Sort for display so order isn't clear

            let html = "";
            if (!allSolved) {
                html += `<p style="color:#e57373">LOCK DISABLED. MISSING DATA.</p>`;
                html += `<p>COLLECT ALL 4 NUMBERS TO ACTIVATE.</p>`;
                html += `<p>COLLECTED: [ ${collectedDigits.join(" ")} ]</p>`;
                modalContent.innerHTML = html;
                optionsContainer.innerHTML = ""; 
                return;
            }

            // All solved
            html += `<p>ENTER 4-DIGIT PASSCODE</p>`;
            html += `<p>AVAILABLE NUMBERS: [ ${collectedDigits.join(" - ")} ]</p>`;
            
            if (safeAttempts <= 1) {
                html += `<p style="color:#ffb74d; font-style:italic; border:1px solid #ffb74d; padding:5px;">HINT: A year of beginning.</p>`;
            }

            html += `<div id="codeDisplay">${currentCode.padEnd(4, '_')}</div>
                     <p style="font-size:14px; color:#e57373;">ATTEMPTS REMAINING: ${safeAttempts}</p>`;
            modalContent.innerHTML = html;
            
            const kpDiv = document.createElement('div'); kpDiv.id = "keypad";
            for(let i=1; i<=9; i++) {
                const btn = document.createElement('div'); btn.className = 'key-btn'; btn.textContent = i; btn.onclick = () => handleKeypad(i); kpDiv.appendChild(btn);
            }
            const clearBtn = document.createElement('div'); clearBtn.className = 'key-btn'; clearBtn.textContent = "C"; clearBtn.onclick = () => { currentCode = ""; renderSafeKeypad(); }; kpDiv.appendChild(clearBtn);
            const zeroBtn = document.createElement('div'); zeroBtn.className = 'key-btn'; zeroBtn.textContent = "0"; zeroBtn.onclick = () => handleKeypad(0); kpDiv.appendChild(zeroBtn);
            const enterBtn = document.createElement('div'); enterBtn.className = 'key-btn'; enterBtn.textContent = "E"; enterBtn.style.color = '#4caf50'; enterBtn.onclick = () => checkSafeCode(); kpDiv.appendChild(enterBtn);
            modalContent.appendChild(kpDiv);
            optionsContainer.innerHTML = ""; modalFeedback.textContent = "";
        }

        function handleKeypad(num) {
            const allSolved = activeClues.every(c => c.solved);
            if(!allSolved) return;

            if(currentCode.length < 4) {
                currentCode += num; 
                const displayEl = document.getElementById('codeDisplay');
                if(displayEl) displayEl.textContent = currentCode.padEnd(4, '_');
            }
        }

        function triggerVictory() {
            gameWon = true;
            modal.style.display = 'none';
            controls.lock();
            isInteracting = false; 

            const startRot = doorPivot.rotation.y;
            const targetRot = -Math.PI / 2; 
            const duration = 2000;
            const startTime = performance.now();

            function animateDoor(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - t, 3);
                doorPivot.rotation.y = startRot + (targetRot - startRot) * ease;

                if (t < 1) {
                    requestAnimationFrame(animateDoor);
                } else {
                    setTimeout(() => {
                        document.getElementById('victoryModal').style.display = 'flex';
                        document.getElementById('victoryTime').textContent = `TIME LEFT: ${finalTimeStr}`;
                        document.exitPointerLock();
                    }, 500);
                }
            }
            requestAnimationFrame(animateDoor);
        }

        function checkSafeCode() {
            if(currentCode === "1858") {
                modalTitle.textContent = "SAFE UNLOCKED";
                modalContent.innerHTML = "<h2 style='color:#4caf50'>SUCCESS</h2><p>The safe opens.</p><p>Inside, you find an old <strong>SKELETON KEY</strong>.</p>";
                hasSkeletonKey = true;
                optionsContainer.innerHTML = "";
                const takeBtn = document.createElement('button'); 
                takeBtn.className = 'option-btn'; 
                takeBtn.textContent = "TAKE KEY";
                takeBtn.onclick = () => { 
                    modal.style.display='none'; 
                    controls.lock(); 
                    isInteracting = false; // Fix: Reset interaction state
                };
                optionsContainer.appendChild(takeBtn);
            } else {
                safeAttempts--;
                if(safeAttempts <= 0) {
                    resetGameLogic();
                } else {
                    modalFeedback.style.color = 'red'; modalFeedback.textContent = "INVALID CODE";
                    currentCode = ""; 
                    renderSafeKeypad(); // Re-render to update attempts
                }
            }
        }

        // Flavor Text Pool
        const flavorTextPool = {
            "lunchbox": [
                "Smells like old egg salad...", 
                "Just a few crumbs and a wrapper.", 
                "An empty juice box and a note from Mom.", 
                "Nothing but air and disappointment.",
                "A banana peel from the mesozoic era.",
                "Someone's sandwich is growing fuzz.",
                "It's locked. Probably for the best.",
                "An apple core and a spooky ghost story.",
                "Thermos is empty. Tragedy.",
                "Just a spoon. There is no spoon?"
            ],
            "trash": [
                "Just wadded up drafts of bad poetry.", 
                "An empty soda can and some lint.", 
                "Why are you digging in the trash?", 
                "It's empty, thankfully.",
                "A crumpled paper that says 'The plan'. It's blank.",
                "Candy wrappers and regret.",
                "Broken pencils and shattered dreams.",
                "A receipt for a 'Time Machine'. It's expired.",
                "Banana peel. classic comedy prop.",
                "Nothing here worth getting your hands dirty for."
            ],
            "mug": [
                "Stained with years of black coffee.", 
                "World's Okayest Archivist.", 
                "There's some mold growing at the bottom.", 
                "Empty. Need more caffeine.",
                "It says 'I hate Mondays'. Irony.",
                "Cold tea dregs.",
                "A chipped rim. Dangerous.",
                "Smells like peppermint and dust.",
                "Bone dry.",
                "It's stuck to the table. Sticky."
            ],
            "plant": [
                "It's plastic. Very convincing.", 
                "Needs water. Or dusting. Or both.", 
                "I think it's judging me.", 
                "A fake fern. Or is it?",
                "It whispered something. Just the wind?",
                "Leaves are brown. It's dead, Jim.",
                "There's a bug on it. Eww.",
                "Photosynthesizing quietly.",
                "Do not eat the foliage.",
                "It's seen things."
            ],
            "computer": [
                "It's locked. Password hint: 'Password'.", 
                "Blue Screen of Death.", 
                "Just a screensaver of flying toasters.", 
                "Searching for 'How to escape an archive'.",
                "404: Clue not found.",
                "System update 1 of 145...",
                "Keyboard is missing the 'Esc' key.",
                "It's running Windows 95.",
                "You have died of dysentery.",
                "A sticky note says 'Turn it off and on again'."
            ],
            "filing_cabinet": [
                "Tax returns from 1982.", 
                "Mothballs and dust.", 
                "Empty folders labeled 'Top Secret'.", 
                "Just a ham sandwich?",
                "A file on 'UFO sightings in Duluth'.",
                "Recipes for hotdish.",
                "Overdue library book notices.",
                "Drawer is stuck. Ugh.",
                "Just paperwork. Boring paperwork.",
                "A collection of rubber bands."
            ],
            "generic": [
                "Just dust bunnies.", 
                "Nothing useful here.", 
                "Empty.", 
                "Looks insignificant.", 
                "Nothing to see here.", 
                "Just clutter.",
                "Move along, nothing to see.",
                "This is not the clue you are looking for.",
                "Just a normal object. Suspiciously normal.",
                "Nope.",
                "Try looking somewhere else.",
                "It's just a thing.",
                "Why is this even here?",
                "A spider scuttles away.",
                "Totally useless.",
                "Red herring.",
                "I wonder who dusted this last?",
                "Nothing inside.",
                "Just emptiness.",
                "Keep searching!",
                "Not a clue.",
                "Just an object acting natural."
            ],
            "lamp": ["I love lamp.", "It's bright. Ow.", "Sheds some light on the situation.", "Flickering ominously.", "Just a lightbulb moment."],
            "clock": ["Time is ticking.", "Is it stopped? No, just slow.", "Tick... tock...", "Late for a very important date.", "Time flies when you're escaping."],
            "radio": ["Playing static.", "Scanning for alien signals.", "It's stuck on the polka station.", "Just white noise.", "Breaking news: You're still trapped."],
            "trophy": ["'Participation Award 1998'.", "First place in 'Being a Trophy'.", "Shiny. But useless.", "Dusty gold plastic.", "World's Best Detective? Not yet."],
            "hat": ["A fancy fedora.", "Not my size.", "M'lady.", "Hides a bad hair day.", "A detective's essential tool."],
            "briefcase": ["Locked. Probably full of papers.", "Smells like leather and business.", "Top secret documents? Nope, just a sandwich.", "Heavy.", "It's definitely not empty, but I can't open it."],
            "globe": ["I can see my house from here!", "Flat earthers beware.", "Spinning around the world.", "Where in the world is Carmen Sandiego?", "The world is your oyster."],
            "typewriter": ["All work and no play...", "Clickety-clack.", "The ribbon is dry.", "It's writing a novel by itself.", "A relic of the past."],
            "book_cluster": ["'History of Lint'. Fascinating.", "Just boring encyclopedias.", "A hollowed out book! ...Wait, no, just a book.", "Pages and pages of words.", "Dusty old tomes."],
            "picture": ["A lovely landscape.", "The eyes follow you.", "Is that a hidden safe behind it? No.", "Just art.", "A picture is worth a thousand words."],
            "fire_extinguisher": ["In case of emergency, break glass.", "Safety first!", "Heavy and red.", "Not a toy.", "Hope I don't need this."],
            "cardboard_box": ["A cat trap.", "Just an empty box.", "Fragile.", "This side up.", "What's in the box?!"],
            "keyboard": ["Sticky keys. Gross.", "QWERTY or Dvorak?", "Missing the 'Any' key.", "Someone spilled coffee on this.", "Clickety-clack."],
            "mouse": ["It's not a real mouse.", "Needs a mousepad.", "Scroll wheel is stuck.", "Double click to... do nothing.", "Squeak? No."]
        };

        function getFlavorText(objName) {
            let key = "generic";
            if (objName.includes("filing_cabinet")) key = "filing_cabinet";
            else if (objName.includes("book_cluster")) key = "book_cluster";
            else if (objName.includes("lamp")) key = "lamp";
            else if (flavorTextPool[objName]) key = objName;
            
            const pool = flavorTextPool[key];
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function showModal(objName) {
            if (objName === "door") {
                if(hasSkeletonKey) {
                    triggerVictory();
                } else {
                    modalTitle.textContent = "LOCKED";
                    modalContent.innerHTML = "<p>The door is locked tight.</p><p>It requires a specific key.</p>";
                    optionsContainer.innerHTML = ""; modalFeedback.textContent = "";
                    modal.style.display = 'block'; controls.unlock(); isInteracting = true;
                }
                return;
            }
            
            if (objName === "safe") {
                currentCode = ""; renderSafeKeypad(); modal.style.display = 'block'; controls.unlock(); isInteracting = true; return;
            }

            const slotIndex = locationMap[objName];
            modalFeedback.textContent = ""; optionsContainer.innerHTML = "";
            if (slotIndex === null || slotIndex === undefined) {
                const displayName = objName.replace(/_/g, ' ').toUpperCase();
                modalTitle.textContent = displayName; 
                const flavor = getFlavorText(objName);
                modalContent.innerHTML = `<p>${flavor}</p>`;
            } else {
                const clueData = activeClues[slotIndex]; const qData = questionPool[clueData.qIndex];
                if(clueData.solved) {
                     modalTitle.textContent = "SOLVED"; modalContent.innerHTML = `<p>${qData.q}</p><p style='color: #4caf50;'><strong>You found a number: ${clueData.digit}</strong></p>`;
                } else {
                    modalTitle.textContent = qData.t; modalContent.innerHTML = `<div class='question-box'><strong>${qData.q}</strong></div>`;
                    
                    const options = qData.o.map((text, idx) => ({ text, isCorrect: idx === qData.c }));
                    options.sort(() => Math.random() - 0.5);

                    options.forEach((opt) => {
                        const btn = document.createElement('button'); btn.className = 'option-btn'; btn.textContent = opt.text;
                        btn.onclick = () => handleAnswer(slotIndex, opt.isCorrect, btn, objName); optionsContainer.appendChild(btn);
                    });
                }
            }
            modal.style.display = 'block'; controls.unlock(); isInteracting = true;
        }

        function handleAnswer(slotIndex, isCorrect, btnElement, objName) {
            const allBtns = document.querySelectorAll('.option-btn'); allBtns.forEach(b => b.disabled = true);
            if(isCorrect) {
                btnElement.classList.add('correct'); modalFeedback.style.color = "#4caf50";
                modalFeedback.innerHTML = `CORRECT! <br>You found a number: <strong>${activeClues[slotIndex].digit}</strong>`;
                activeClues[slotIndex].solved = true;
            } else {
                btnElement.classList.add('wrong'); modalFeedback.style.color = "#e57373";
                const newLoc = moveClue(slotIndex, objName);
                modalFeedback.innerHTML = `WRONG! The clue has vanished.<br>You must find it again elsewhere.`;
            }
        }

        document.addEventListener('mousedown', () => {
            if (controls.isLocked && !isInteracting) {
                const obj = checkIntersection(); if (obj) showModal(obj.name);
            }
        });

        const instructions = document.getElementById('instructions');
        instructions.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => instructions.style.display = 'none');
        controls.addEventListener('unlock', () => { if(!isInteracting) instructions.style.display = ''; });

        const keys = { w: false, a: false, s: false, d: false };
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW' || e.code==='ArrowUp') keys.w=true; if(e.code==='KeyA' || e.code==='ArrowLeft') keys.a=true;
            if(e.code==='KeyS' || e.code==='ArrowDown') keys.s=true; if(e.code==='KeyD' || e.code==='ArrowRight') keys.d=true;
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW' || e.code==='ArrowUp') keys.w=false; if(e.code==='KeyA' || e.code==='ArrowLeft') keys.a=false;
            if(e.code==='KeyS' || e.code==='ArrowDown') keys.s=false; if(e.code==='KeyD' || e.code==='ArrowRight') keys.d=false;
        });

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            updateTimer(delta);
            if (controls.isLocked) {
                checkIntersection();
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(keys.w) - Number(keys.s);
                direction.x = Number(keys.d) - Number(keys.a);
                direction.normalize(); 
                if (keys.w || keys.s) velocity.z -= direction.z * 100.0 * delta; 
                if (keys.a || keys.d) velocity.x -= direction.x * 100.0 * delta;
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                const pos = controls.getObject().position;
                if (pos.x < -4.5) pos.x = -4.5; if (pos.x > 4.5) pos.x = 4.5;
                if (pos.z < -4.5) pos.z = -4.5; if (pos.z > 4.5) pos.z = 4.5;
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
